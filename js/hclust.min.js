/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ml-hclust@3.1.0/hclust.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var mlDistanceEuclidean=require("ml-distance-euclidean"),getDistanceMatrix=require("ml-distance-matrix"),mlMatrix=require("ml-matrix"),Heap=require("heap");function _interopDefaultLegacy(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var getDistanceMatrix__default=_interopDefaultLegacy(getDistanceMatrix),Heap__default=_interopDefaultLegacy(Heap);class Cluster{constructor(){this.children=[],this.height=0,this.size=1,this.index=-1,this.isLeaf=!1}cut(e){if("number"!=typeof e)throw new TypeError("threshold must be a number");if(e<0)throw new RangeError("threshold must be a positive number");let t=[this];const r=[];for(;t.length>0;){const n=t.shift();e>=n.height?r.push(n):t=t.concat(n.children)}return r}group(e){if(!Number.isInteger(e)||e<1)throw new RangeError("groups must be a positive integer");const t=new Heap__default.default(((e,t)=>t.height-e.height));for(t.push(this);t.size()<e;){const e=t.pop();if(0===e.children.length)break;e.children.forEach((e=>t.push(e)))}const r=new Cluster;return r.children=t.toArray(),r.height=this.height,r}traverse(e){!function e(t,r){if(r(t),t.children)for(const n of t.children)e(n,r)}(this,e)}indices(){const e=[];return this.traverse((t=>{t.isLeaf&&e.push(t.index)})),e}}function singleLink(e,t){return Math.min(e,t)}function completeLink(e,t){return Math.max(e,t)}function averageLink(e,t,r,n,i){return n/(n+i)*e+i/(n+i)*t}function weightedAverageLink(e,t){return(e+t)/2}function centroidLink(e,t,r,n,i){return n/(n+i)*e+i/(n+i)*t+-n*i/(n+i)**2*r}function medianLink(e,t,r){return e/2+t/2-r/4}function wardLink(e,t,r,n,i,s){return(n+s)/(n+i+s)*e+(i+s)/(n+i+s)*t+-s/(n+i+s)*r}function wardLink2(e,t,r,n,i,s){const a=(n+s)/(n+i+s),o=(i+s)/(n+i+s),c=-s/(n+i+s);return Math.sqrt(a*e*e+o*t*t+c*r*r)}function agnes(e,t={}){const{distanceFunction:r=mlDistanceEuclidean.euclidean,method:n="complete",isDistanceMatrix:i=!1}=t;let s;i||(e=getDistanceMatrix__default.default(e,r));let a=new mlMatrix.Matrix(e);const o=a.rows;if("string"==typeof n)switch(n.toLowerCase()){case"single":s=singleLink;break;case"complete":s=completeLink;break;case"average":case"upgma":s=averageLink;break;case"wpgma":s=weightedAverageLink;break;case"centroid":case"upgmc":s=centroidLink;break;case"median":case"wpgmc":s=medianLink;break;case"ward":s=wardLink;break;case"ward2":s=wardLink2;break;default:throw new RangeError(`unknown clustering method: ${n}`)}else if("function"!=typeof n)throw new TypeError("method must be a string or function");let c=[];for(let e=0;e<o;e++){const t=new Cluster;t.isLeaf=!0,t.index=e,c.push(t)}for(let e=0;e<o-1;e++){const[e,t,r]=getSmallestDistance(a),n=c[e],i=c[t],o=new Cluster;o.size=n.size+i.size,o.children.push(n,i),o.height=r;const u=[o],l=new mlMatrix.Matrix(a.rows-1,a.rows-1),h=r=>getPreviousIndex(r,Math.min(e,t),Math.max(e,t));for(let o=1;o<l.rows;o++){const f=h(o),g=c[f];u.push(g);for(let c=0;c<o;c++)if(0===c){const u=s(a.get(e,f),a.get(f,t),r,n.size,i.size,g.size);l.set(o,c,u),l.set(c,o,u)}else{const e=a.get(f,h(c));l.set(o,c,e),l.set(c,o,e)}}c=u,a=l}return c[0]}function getSmallestDistance(e){let t=1/0,r=0,n=0;for(let i=1;i<e.rows;i++)for(let s=0;s<i;s++)e.get(i,s)<t&&(t=e.get(i,s),r=i,n=s);return[r,n,t]}function getPreviousIndex(e,t,r){return(e-=1)>=t&&e++,e>=r&&e++,e}exports.Cluster=Cluster,exports.agnes=agnes;
//# sourceMappingURL=/sm/464e6673cab81ea04177fcc76e64847109f12cad7be74a89543f0993b84844a6.map